#!/usr/bin/env bash
# Build a MacOS virtual machine that runs Claude Code and developer tools
set -euo pipefail
trap 'echo "$0: line $LINENO: $BASH_COMMAND: exitcode $?"' ERR
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[@]}")" && pwd)"
WORKSPACE="$(realpath "$SCRIPT_DIR")"


###############################################################################
# Definitions
###############################################################################
VERSION="1.0.2"
MACOS_IMAGE="ghcr.io/cirruslabs/macos-sequoia-xcode:latest"
BASE_VM_NAME="clodpod-xcode-base"
DST_VM_NAME="clodpod-xcode"
DB_FILE="$WORKSPACE/.clodpod.sqlite"


###############################################################################
# Functions
###############################################################################
trace () {
    [[ "${VERBOSE_LEVEL:-0}" -lt 2 ]] || echo >&2 -e "üî¨ \033[36m$*\033[0m"
}
debug () {
    [[ "${VERBOSE_LEVEL:-0}" -lt 1 ]] || echo >&2 -e "üîç \033[36m$*\033[0m"
}
info () {
    echo >&2 -e "‚ÑπÔ∏è \033[36m$*\033[0m"
}
warn () {
    echo >&2 -e "‚ö†Ô∏è \033[33m$*\033[0m"
}
error () {
    echo >&2 -e "‚ùå \033[31m$*\033[0m"
}
abort () {
    error "$*"
    exit 1
}


###############################################################################
# Preconditions
###############################################################################
if [[ $OSTYPE != 'darwin'* ]]; then
    abort "ERROR: this script is for Mac OSX"
fi
if [[ ! -f "$HOME/.claude.json" ]]; then
    abort "ERROR: missing '$HOME/.claude.json'"
fi


###############################################################################
# Functions
###############################################################################
# heredoc MESSAGE << EOF
#    your favorite text here
# EOF
heredoc(){ IFS=$'\n' read -r -d '' "${1}" || true; }

get_vm_state () {
    local vm_name="$1"
    local vm_source="${2:-local}"
    tart list --source "$vm_source" --format json \
        | jq -r ".[] | select(.Name == \"$vm_name\") | .State" 2>/dev/null \
        || echo ""
}

get_vm_exists () {
    local vm_name="$1"
    local vm_source="${2:-local}"
    [[ "$(get_vm_state "$vm_name" "$vm_source")" != "" ]]
}

wait_vm_state () {
    local vm_name="$1"
    local desired_state="$2"
    local timeout=20
    local elapsed=0

    while [[ $elapsed -lt $timeout ]]; do
        local state
        state="$(get_vm_state "$vm_name")"
        if [[ "$state" == "$desired_state" ]]; then
            debug "VM $vm_name is $desired_state"
            return 0
        fi
        trace "‚è≥ Waiting for $vm_name to be $desired_state... ($elapsed/$timeout seconds)"
        sleep 1
        ((elapsed++)) || true
    done
    abort "VM $vm_name failed to be $desired_state within $timeout seconds"
}

wait_vm_running () {
    wait_vm_state "$1" "running"
}

run_vm () {
    local vm_name="$1"
    debug "Running $vm_name"

    # Get directories to map into the VM
    local args=()
    get_map_directories args
    [[ "${NO_GRAPHICS:-}" == "" ]] || args+=("--no-graphics")

    tart run \
        "${args[@]}" \
        "$vm_name" </dev/null &>/dev/null & disown
    wait_vm_running "$vm_name"
    # Mark all projects as active after virtual machine starts successfully
    sqlite3 "$DB_FILE" <<EOF
UPDATE projects SET active = 1;
EOF
}

stop_vm () {
    local vm_name="$1"
    if [[ "$(get_vm_state "$vm_name")" != "stopped" ]]; then
        debug "Stopping $vm_name..."
        tart stop "$vm_name"
        wait_vm_state "$vm_name" "stopped"
    fi
}

clone_vm () {
    local src_vm_name="$1"
    local dst_vm_name="$2"
    trace "Cloning $src_vm_name to $dst_vm_name..."
    tart clone "$src_vm_name" "$dst_vm_name"
    tart set "$dst_vm_name" --random-mac --random-serial
    tart set "$dst_vm_name" --cpu "$(sysctl -n hw.ncpu)"
    tart set "$dst_vm_name" --memory "$(( $(sysctl -n hw.memsize) * 5 / 8 / 1048576 ))"
}

stop_all_vms () {
    local running_vms
    running_vms=$(tart list --format json | jq -r '.[] | select(.State == "running") | .Name')

    info "Stopping all clodpod virtual machines"
    if [[ -n "$running_vms" ]]; then
        while IFS= read -r vm_name; do
            if [[ "$vm_name" =~ ^clodpod- ]]; then
                stop_vm "$vm_name"
            fi
            if [[ "$vm_name" =~ ^clodpod-tmp ]]; then
                delete_vm "$vm_name"
            fi
        done <<< "$running_vms"
    fi
}

delete_vm () {
    local vm_name="$1"
    if tart list --quiet | grep "^$vm_name$" >/dev/null ; then
        stop_vm "$vm_name"
        debug "Deleting $vm_name..."
        tart delete "$vm_name" &>/dev/null || true
    fi
}

cleanup_tmp_vm () {
    if [[ -n "${TMP_VM_NAME:-}" ]]; then
        delete_vm "$TMP_VM_NAME"
    fi
}

init_db() {
    debug "Creating $DB_FILE database..."
    sqlite3 "$DB_FILE" <<EOF
CREATE TABLE IF NOT EXISTS projects (
    path TEXT UNIQUE NOT NULL,
    name TEXT UNIQUE NOT NULL,
    date_added TEXT DEFAULT (datetime('now')),
    active INTEGER DEFAULT 0
);
EOF
}

check_projects_active() {
    # Returns 0 (success) if all projects are active, 1 otherwise
    local inactive_count
    inactive_count=$(sqlite3 "$DB_FILE" <<EOF
SELECT COUNT(*) FROM projects WHERE active = 0;
EOF
)
    trace "Inactive projects: $inactive_count"
    [[ "$inactive_count" -eq 0 ]]
}

add_project () {
    local path="${1:-}"
    local name="${2:-}"

    if [[ -z "$path" ]]; then
        error "Error: path is required to add project"
        return 1
    fi
    if [[ ! -d "$path" ]]; then
        error "Error: directory not found ($path)"
        return 1
    fi

    # Use basename of path if name not provided
    path="$(realpath "$path")"
    if [[ -z "$name" ]]; then
        name="$(basename "$path")"
    fi

    sqlite3 "$DB_FILE" <<EOF
INSERT OR IGNORE INTO projects (path, name, date_added) VALUES ('$path', '$name', datetime('now'));
EOF
    sqlite3 "$DB_FILE" <<EOF
UPDATE projects set date_added = datetime('now') where name = '$name';
EOF

    info "Added project $name ($path)"
}

remove_project() {
    local identifier="${1:-}"

    if [[ -z "$identifier" ]]; then
        error "Error: Project name or path required to remove project"
        return 1
    fi
    path="$(realpath "$identifier")"

    # Try to remove by name first, then by path
    local rows_affected
    rows_affected=$(sqlite3 "$DB_FILE" <<EOF
DELETE FROM projects WHERE name = '$identifier' OR path = '$identifier' OR path = '$path';
SELECT changes();
EOF
)

    if [[ ${rows_affected:-0} -gt 0 ]]; then
        info "Removed project $identifier"
    else
        error "Error: Project not found ($identifier)"
        return 1
    fi
}

list_projects() {
    sqlite3 -column -header "$DB_FILE" <<EOF || return 1
SELECT name, path, CASE WHEN active = 1 THEN 'yes' ELSE 'no' END as active, date_added FROM projects ORDER BY date_added DESC;
EOF
}

# Get all projects as bash array with --dir format
# Usage: get_map_directories ARRAY_NAME
# Populates the named array with entries like: "--dir" "name:path"
get_map_directories() {
    local -n arr="$1"
    arr=()

    local result
    result=$(sqlite3 -separator '|' "$DB_FILE" <<EOF || return 1
SELECT name, path FROM projects ORDER BY date_added DESC;
EOF
)

    # Always map the guest directory into the VM as "__install"
    # so install/configure scripts are available during build
    arr+=("--dir" "__install:$WORKSPACE/guest")

    if [[ -n "$result" ]]; then
        while IFS='|' read -r name path; do
            arr+=("--dir" "${name}:${path}")
        done <<< "$result"
    fi
}


###############################################################################
# Parse command line options
###############################################################################
VERBOSE_LEVEL="${VERBOSE_LEVEL:-0}"
NO_GRAPHICS="${NO_GRAPHICS:-}"

show_help() {
    appname=$(basename "$0")
    echo "Usage: $appname [options] command [args...]"
    echo ""
    echo "Options:"
    echo "  --no-graphics        Run virtual machine without graphics"
    echo "  --rebuild-base       Force rebuild of the base image (brew update)"
    echo "  --rebuild-dst        Force rebuild of the final image (update \$HOME)"
    echo "  -v, --verbose        Enable verbose output (repeat for more verbosity)"
    echo "  -vv                  Set verbosity level 2"
    echo "  -vvv                 Set verbosity level 3"
    echo "  -h, --help           Show this help message"
    echo "  --version            Show version information"
    echo ""
    echo "Commands:"
    echo "  run [PATH] [NAME]    Run virtual machine with claude"
    echo "  shell [PATH] [NAME]  Run virtual machine with shell"
    echo "  stop                 Stop running all clodpod virtual machines"
    echo "  list                 List all projects"
    echo "  add PATH [NAME]      Add a new project (name defaults to basename of path)"
    echo "  remove <identifier>  Remove project by name or path"
    exit 0
}

show_version() {
    echo "clod version $VERSION"
    exit 0
}

# Parse options before parsing command
NEW_ARGS=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        -v|--verbose)
            ((VERBOSE_LEVEL++)) || true
            shift
            ;;
        -vv)
            ((VERBOSE_LEVEL+=2)) || true
            shift
            ;;
        -vvv)
            ((VERBOSE_LEVEL+=3)) || true
            shift
            ;;
        --no-graphics)
            NO_GRAPHICS=true
            shift
            ;;
        --rebuild-base)
            REBUILD_BASE=true
            shift
            ;;
        --rebuild-dst)
            REBUILD_DST=true
            shift
            ;;
        -h|--help)
            show_help
            ;;
        --version)
            show_version
            ;;
        -*)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
        *)
            NEW_ARGS+=("$1")
            shift
            ;;
    esac
done
set -- "${NEW_ARGS[@]}"


###############################################################################
# Parse command line
###############################################################################
init_db

case "${1:-}" in
    run)
        COMMAND=claude
        ARG_DIR="${2:-}"
        ARG_NAME="${3:-}"
        ;;
    shell)
        unset COMMAND
        ARG_DIR="${2:-}"
        ARG_NAME="${3:-}"
        ;;
    stop)
        stop_all_vms
        exit 0
        ;;
    add)
        add_project "${2:-}" "${3:-}"
        exit 0
        ;;
    remove|rm)
        remove_project "${2:-}"
        exit 0
        ;;
    list|ls)
        list_projects
        exit 0
        ;;
    *)
        show_help
        ;;
esac

# Add project if requested
if [[ -n "${ARG_DIR:-}" ]]; then
    add_project "$ARG_DIR" "$ARG_NAME"
fi

# If no projects exist then add the current directory as a project
if [[ "$(sqlite3 "$DB_FILE" "SELECT COUNT(*) FROM projects;" 2>/dev/null)" -eq 0 ]]; then
    # Try to set the project directory to the top-level directory of the git repository
    # to minimize the number of directories that get mapped into the virtual machine.
    PROJECT_DIR="$(git rev-parse --show-toplevel 2>/dev/null)" || PROJECT_DIR="$PWD"
    PROJECT="$(basename "$PROJECT_DIR")"
    add_project "$PROJECT_DIR" "$PROJECT"
else
    IFS='|' read -r PROJECT PROJECT_DIR < <(sqlite3 "$DB_FILE" "SELECT name, path FROM
        projects ORDER BY date_added DESC LIMIT 1;" 2>/dev/null)
    if [[ -z "${ARG_DIR:-}" ]]; then
        info "Using project $PROJECT ($PROJECT_DIR)"
    fi
fi


###############################################################################
# Install required tools
###############################################################################
install_tools () {
    debug "Installing tools..."
    local TOOLS=()
    TOOLS+=("cirruslabs/cli/tart")      # macOS and Linux VMs on Apple Silicon
    TOOLS+=("jq")                       # JSON processing tool
    TOOLS+=("netcat")                   # test connectivity to guest VM
    TOOLS+=("rush")                     # Restricted User SHell
    TOOLS+=("sqlite3")                  # database for projects

    # Hide output of brew if VERBOSE_LEVEL is <3
    local QUIET=("--quiet")
    [[ "${VERBOSE_LEVEL:-0}" -lt 3 ]] || QUIET=()

    for tool in "${TOOLS[@]}"; do
        if ! command -v "$(basename "$tool")" &>/dev/null ; then
            info "Installing $tool"
            brew install "${QUIET[@]}" "$tool"
        fi
    done
}
install_tools


###############################################################################
# Create passwordless SSH key with permission to remotely login to guest
###############################################################################
SSH_DIR="$HOME/.ssh"
SSH_KEYFILE_PRIV="$SSH_DIR/id_ed25519_clodpod"
SSH_KEYFILE_PUB="$SSH_KEYFILE_PRIV.pub"
if [[ ! -f "$SSH_KEYFILE_PRIV" ]] || [[ ! -f "$SSH_KEYFILE_PUB" ]]; then
    mkdir -p "$SSH_DIR"
    ssh-keygen -t ed25519 \
        -f "$SSH_KEYFILE_PRIV" \
        -N "" \
        -q \
        -C "clodpod-${USER}@${HOSTNAME}"
    REBUILD_DST=true
fi


###############################################################################
# Download MACOS image
###############################################################################
if ! get_vm_exists "$MACOS_IMAGE" "oci" ; then
    # Defer downloading the image until after asking to stop
    # running images to avoid asking questions after a long delay
    DOWNLOAD_IMAGE=true

    # This is probably the first time install; be more verbose
    [[ "${VERBOSE_LEVEL:-0}" -ge 2 ]] || VERBOSE_LEVEL=2

    # Changing the MACOS image requires rebuild
    REBUILD_BASE=true
elif ! get_vm_exists "$BASE_VM_NAME" ; then
    REBUILD_BASE=true
elif ! get_vm_exists "$DST_VM_NAME" ; then
    REBUILD_DST=true
fi

if [[ "${REBUILD_BASE:-}" != "" ]]; then
    REBUILD_DST=true
fi

if [[ "${REBUILD_DST:-}" != "" ]]; then
    if [[ "$(get_vm_state "$DST_VM_NAME")" == "running" ]]; then
        read -p "$DST_VM_NAME is running; delete it? (y/N)" -n 1 -r response
        echo
        [[ "$response" =~ ^[Yy]$ ]] || exit 0
    fi
    delete_vm "$DST_VM_NAME"
fi

if [[ "${DOWNLOAD_IMAGE:-}" != "" ]]; then
    debug "Downloading image..."
    tart pull "$MACOS_IMAGE" # >/dev/null
fi


###############################################################################
# Configure virtual machine settings
###############################################################################
if [[ "${REBUILD_DST:-}" != "" ]]; then
    debug "Configuring credentials..."

    # Copy claude configuration file, excluding things we don't need
    warn "Disabling claude auto-updates until they fix their bug"
    warn "- https://github.com/anthropics/claude-code/issues/5118"
    jq  'del(.projects, .cachedChangelog, .tipsHistory, .mcpServers) | .autoUpdates = false' \
        "$HOME/.claude.json" > "$WORKSPACE/guest/home/.claude.json"

    # Get git config from host
    GIT_USER_NAME=$(git config --global --get user.name 2>/dev/null || echo "")
    GIT_USER_EMAIL=$(git config --global --get user.email 2>/dev/null || echo "")
    git config set -f "$WORKSPACE/guest/home/.gitconfig" user.name "$GIT_USER_NAME"
    git config set -f "$WORKSPACE/guest/home/.gitconfig" user.email "$GIT_USER_EMAIL"

    # Add SSH public key to host's authorized_keys
    GUEST_AUTHORIZED_KEYS="$WORKSPACE/guest/home/.ssh/authorized_keys"
    mkdir -p "$(dirname "$GUEST_AUTHORIZED_KEYS")"
    cp "$SSH_KEYFILE_PUB" "$GUEST_AUTHORIZED_KEYS"
    chmod 600 "$GUEST_AUTHORIZED_KEYS"
fi


###############################################################################
# Create Base VM
###############################################################################
# It's possible this script will fail or be cancelled halfway
# through so build to a temporary image and rename when complete
TMP_VM_NAME="clodpod-tmp-$(openssl rand -hex 8)"
trap cleanup_tmp_vm EXIT

if [[ "${REBUILD_BASE:-}" != "" ]]; then
    debug "Building $BASE_VM_NAME..."
    delete_vm "$BASE_VM_NAME"

    trace "Cloning image to $TMP_VM_NAME..."
    clone_vm "$MACOS_IMAGE" "$TMP_VM_NAME"
    run_vm "$TMP_VM_NAME"

    trace "Running install.sh..."
    tart exec -it "$TMP_VM_NAME" \
        "/usr/bin/env" "VERBOSE_LEVEL=${VERBOSE_LEVEL:-0}" bash \
        "/Volumes/My Shared Files/__install/install.sh"

    trace "Renaming $TMP_VM_NAME to $BASE_VM_NAME"
    tart rename "$TMP_VM_NAME" "$BASE_VM_NAME"

    debug "Building $BASE_VM_NAME successful"
fi


###############################################################################
# Create Dst VM
###############################################################################
if [[ "${REBUILD_DST:-}" != "" ]]; then
    debug "Building $DST_VM_NAME..."

    # If the base image is already running then do some jiggery-pokery
    # to rename it so we can avoid stopping the VM and starting another.
    #
    # Note that this leaves the application window title unchanged, but
    # it's faster than stopping and starting the VM.
    if [[ "$(get_vm_state "$BASE_VM_NAME")" == "running" ]]; then
        tart rename "$BASE_VM_NAME" "$TMP_VM_NAME"
        clone_vm "$TMP_VM_NAME" "$BASE_VM_NAME"
    else
        clone_vm "$BASE_VM_NAME" "$TMP_VM_NAME"
        run_vm "$TMP_VM_NAME"
    fi

    trace "Running configure.sh..."
    tart exec -it "$TMP_VM_NAME" \
        "/usr/bin/env" "VERBOSE_LEVEL=${VERBOSE_LEVEL:-0}" bash \
        "/Volumes/My Shared Files/__install/configure.sh"

    trace "Renaming $TMP_VM_NAME to $DST_VM_NAME"
    tart rename "$TMP_VM_NAME" "$DST_VM_NAME"

    debug "Building $DST_VM_NAME successful"
fi

###############################################################################
# Run the application
###############################################################################
# kitty doesn't set this properly :(
TERM_PROGRAM="${TERM_PROGRAM:-e.g. ghostty, kitty, iTerm, WezTerm}"
heredoc LOCAL_NETWORK_ERROR << EOF
\n
ERROR: unable to connect to $DST_VM_NAME.

Your terminal app ($TERM_PROGRAM)
has not been granted "Local Network" access rights,
which are required to SSH to the Virtual Machine.

- Open "System Settings.app"
- Navigate to "Privacy & Security"
- Select "Local Network"
- Grant access to your terminal application
\n
EOF

if [[ "$(get_vm_state "$DST_VM_NAME")" != "running" ]]; then
    run_vm "$DST_VM_NAME"
elif ! check_projects_active ; then
    warn "New project directory added; virtual machine restart required"
    read -p "$DST_VM_NAME is running; restart it? (y/N)" -n 1 -r response
    echo
    [[ "$response" =~ ^[Yy]$ ]] || exit 0
    stop_vm "$DST_VM_NAME"
    run_vm "$DST_VM_NAME"
fi

debug "Checking $DST_VM_NAME IP connectivity"
IPADDR="$(tart ip --wait 20 "$DST_VM_NAME")"
if ! nc -z "$IPADDR" 22 ; then
    error "$LOCAL_NETWORK_ERROR"
    read -n 1 -s -r -p "Press any key to open System Settings"
    open "/System/Library/PreferencePanes/Security.prefPane"
fi

debug "Connect to $DST_VM_NAME (ssh clodpod@$IPADDR)"
exec ssh \
    -q \
    -t \
    -o StrictHostKeyChecking=no \
    -o UserKnownHostsFile=/dev/null \
    -i "$SSH_KEYFILE_PRIV" \
    "clodpod@$IPADDR" \
    /usr/bin/env "PROJECT=$PROJECT" "COMMAND=${COMMAND:-}" zsh --login
