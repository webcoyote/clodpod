#!/usr/bin/env bash
# Build a MacOS virtual machine that runs Claude Code and developer tools
set -Eeuo pipefail
trap 'echo "${BASH_SOURCE[0]}: line $LINENO: $BASH_COMMAND: exitcode $?"' ERR
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
WORKSPACE="$(realpath "$SCRIPT_DIR")"


###############################################################################
# Overrides
###############################################################################
MACOS_VERSION="${MACOS_VERSION:-tahoe}"
MACOS_FLAVOR="${MACOS_FLAVOR:-xcode}"


###############################################################################
# Functions
###############################################################################
[[ "${VERBOSE:-0}" =~ ^[0-9]+$ ]] && VERBOSE="${VERBOSE:-0}" || VERBOSE=1
trace () {
    [[ "$VERBOSE" -lt 2 ]] || echo >&2 -e "üî¨ \033[90m$*\033[0m"
}
debug () {
    [[ "$VERBOSE" -lt 1 ]] || echo >&2 -e "üîç \033[36m$*\033[0m"
}
info () {
    echo >&2 -e "‚ÑπÔ∏è \033[36m$*\033[0m"
}
warn () {
    echo >&2 -e "‚ö†Ô∏è \033[33m$*\033[0m"
}
error () {
    echo >&2 -e "‚ùå \033[31m$*\033[0m"
}
abort () {
    error "$*"
    exit 1
}


###############################################################################
# Preconditions
###############################################################################
if [[ $OSTYPE != 'darwin'* ]]; then
    abort "ERROR: this script is for Mac OSX"
fi
if [[ ! -f "$HOME/.claude.json" ]]; then
    abort "ERROR: missing '$HOME/.claude.json'"
fi

# https://github.com/orgs/cirruslabs/packages?tab=packages&q=macos-
VALID_MACOS_VERSIONS="tahoe sequoia sonoma ventura monterey"
VALID_MACOS_FLAVORS="vanilla base xcode"

# Convert to lowercase (bash 3.2 compatible)
MACOS_VERSION=$(echo "$MACOS_VERSION" | tr '[:upper:]' '[:lower:]')
MACOS_FLAVOR=$(echo "$MACOS_FLAVOR" | tr '[:upper:]' '[:lower:]')

# Validate
is_valid_version() {
    case " $VALID_MACOS_VERSIONS " in
        *" $1 "*) return 0 ;;
        *) return 1 ;;
    esac
}
is_valid_flavor() {
    case " $VALID_MACOS_FLAVORS " in
        *" $1 "*) return 0 ;;
        *) return 1 ;;
    esac
}

if ! is_valid_version "$MACOS_VERSION"; then
    abort "Unknown MACOS_VERSION $MACOS_VERSION; try $VALID_MACOS_VERSIONS"
fi
if ! is_valid_flavor "$MACOS_FLAVOR"; then
    abort "Unknown MACOS_FLAVOR $MACOS_FLAVOR; try $VALID_MACOS_FLAVORS"
fi


###############################################################################
# Definitions
###############################################################################
VERSION="1.0.15"
BASE_VM_NAME="clodpod-xcode-base"
DST_VM_NAME="clodpod-xcode"
DB_FILE="$WORKSPACE/.clodpod.sqlite"

MACOS_IMAGE="ghcr.io/cirruslabs/macos-$MACOS_VERSION-$MACOS_FLAVOR:latest"
debug "MacOS image: $MACOS_IMAGE"


###############################################################################
# Functions
###############################################################################
# heredoc MESSAGE << EOF
#    your favorite text here
# EOF
heredoc(){ IFS=$'\n' read -r -d '' "${1}" || true; }

install_tools () {
    # Install brew
    if ! command -v brew &> /dev/null ; then
        debug "Installing brew..."
        /usr/bin/env bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    fi

    debug "Installing tools..."
    local TOOLS=()
    TOOLS+=("cirruslabs/cli/tart")      # macOS and Linux VMs on Apple Silicon
    TOOLS+=("jq")                       # JSON processing tool
    TOOLS+=("netcat")                   # test connectivity to guest VM
    TOOLS+=("rush")                     # Restricted User SHell
    TOOLS+=("sqlite3")                  # database for projects

    for tool in "${TOOLS[@]}"; do
        if ! command -v "$(basename "$tool")" &>/dev/null ; then
            trace "Installing $tool..."
            if [[ "$VERBOSE" -lt 3 ]]; then
                brew install --quiet "$tool"
            else
                brew install "$tool"
            fi
        fi
    done
}

get_vm_state () {
    local vm_name="$1"
    local vm_source="${2:-local}"
    tart list --source "$vm_source" --format json \
        | jq -r ".[] | select(.Name == \"$vm_name\") | .State" 2>/dev/null \
        || echo ""
}

get_vm_exists () {
    local vm_name="$1"
    local vm_source="${2:-local}"
    [[ "$(get_vm_state "$vm_name" "$vm_source")" != "" ]]
}

wait_vm_state () {
    local vm_name="$1"
    local desired_state="$2"
    local timeout=20
    local elapsed=0

    while [[ $elapsed -lt $timeout ]]; do
        local state
        state="$(get_vm_state "$vm_name")"
        if [[ "$state" == "$desired_state" ]]; then
            debug "VM $vm_name is $desired_state"
            return 0
        fi
        trace "‚è≥ Waiting for $vm_name to be $desired_state... ($elapsed/$timeout seconds)"
        sleep 1
        ((elapsed++)) || true
    done
    abort "VM $vm_name failed to be $desired_state within $timeout seconds"
}

wait_vm_running () {
    wait_vm_state "$1" "running"
}

run_vm () {
    local vm_name="$1"
    debug "Running $vm_name"

    # Get directories to map into the VM
    local args=()
    while IFS= read -r -d '' arg; do
        args+=("$arg")
    done < <(get_map_directories)
    [[ "${NO_GRAPHICS:-}" == "" ]] || args+=("--no-graphics")

    tart run \
        "${args[@]}" \
        "$vm_name" </dev/null &>/dev/null & disown
    wait_vm_running "$vm_name"
    # Mark all projects as active after virtual machine starts successfully
    sqlite3 "$DB_FILE" <<EOF
UPDATE projects SET active = 1;
EOF
}

stop_vm () {
    local vm_name="$1"
    if [[ "$(get_vm_state "$vm_name")" != "stopped" ]]; then
        debug "Stopping $vm_name..."
        tart stop "$vm_name"
        wait_vm_state "$vm_name" "stopped"
    fi
}

clone_vm () {
    local src_vm_name="$1"
    local dst_vm_name="$2"
    trace "Cloning $src_vm_name to $dst_vm_name..."
    tart clone "$src_vm_name" "$dst_vm_name"
    tart set "$dst_vm_name" --random-mac --random-serial
    tart set "$dst_vm_name" --cpu "$(sysctl -n hw.ncpu)"
    tart set "$dst_vm_name" --memory "$(( $(sysctl -n hw.memsize) * 5 / 8 / 1048576 ))"
}

stop_all_vms () {
    local running_vms
    running_vms=$(tart list --format json | jq -r '.[] | select(.State == "running") | .Name')

    info "Stopping all clodpod virtual machines"
    if [[ -n "$running_vms" ]]; then
        while IFS= read -r vm_name; do
            if [[ "$vm_name" =~ ^clodpod- ]]; then
                stop_vm "$vm_name"
            fi
            if [[ "$vm_name" =~ ^clodpod-tmp ]]; then
                delete_vm "$vm_name"
            fi
        done <<< "$running_vms"
    fi
}

delete_vm () {
    local vm_name="$1"
    if tart list --quiet | grep "^$vm_name$" >/dev/null ; then
        stop_vm "$vm_name"
        debug "Deleting $vm_name..."
        tart delete "$vm_name" &>/dev/null || true
    fi
}

cleanup_tmp_vm () {
    if [[ -n "${TMP_VM_NAME:-}" ]]; then
        delete_vm "$TMP_VM_NAME"
    fi
}

init_db() {
    debug "Creating $DB_FILE database..."
    sqlite3 "$DB_FILE" <<EOF
CREATE TABLE IF NOT EXISTS projects (
    path TEXT UNIQUE NOT NULL,
    name TEXT UNIQUE NOT NULL,
    date_added TEXT DEFAULT (datetime('now')),
    active INTEGER DEFAULT 0
);
CREATE TABLE IF NOT EXISTS settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at TEXT DEFAULT (datetime('now'))
);
EOF
}

get_setting() {
    local key="$1"
    local default_value="${2:-}"
    local value
    value=$(sqlite3 "$DB_FILE" <<EOF
SELECT COALESCE((SELECT value FROM settings WHERE key = '$key' LIMIT 1), '$default_value');
EOF
)
    trace "Setting '$key' resolved to '$value'"
    echo "$value"
}

set_setting() {
    local key="$1"
    local value="$2"
    sqlite3 "$DB_FILE" <<EOF
INSERT OR REPLACE INTO settings (key, value, updated_at)
VALUES ('$key', '$value', datetime('now'));
EOF
}

check_projects_active() {
    # Returns 0 (success) if all projects are active, 1 otherwise
    local inactive_count
    inactive_count=$(sqlite3 "$DB_FILE" <<EOF
SELECT COUNT(*) FROM projects WHERE active = 0;
EOF
)
    trace "Inactive projects: $inactive_count"
    [[ "$inactive_count" -eq 0 ]]
}

add_project () {
    local patharg="${1:-}"
    local name="${2:-}"

    if [[ -z "$patharg" ]]; then
        abort "Error: path is required to add project"
    fi

    local path
    path="$(realpath "$patharg" 2>/dev/null || true)"
    if [[ ! -d "$path" ]]; then
        abort "Error: directory not found ($patharg)"
    fi

    # Use basename of path if name not provided
    if [[ -z "$name" ]]; then
        name="$(basename "$path")"
    fi

    sqlite3 "$DB_FILE" <<EOF
INSERT OR IGNORE INTO projects (path, name, date_added) VALUES ('$path', '$name', datetime('now'));
EOF
    sqlite3 "$DB_FILE" <<EOF
UPDATE projects set date_added = datetime('now') where name = '$name';
EOF

    info "Added project $name ($path)"
}

remove_project() {
    local identifier="${1:-}"

    if [[ -z "$identifier" ]]; then
        error "Error: Project name or path required to remove project"
        return 1
    fi
    path="$(realpath "$identifier" 2>/dev/null || echo "")"

    # Try to remove by name first, then by path
    local rows_affected
    rows_affected=$(sqlite3 "$DB_FILE" <<EOF
DELETE FROM projects WHERE name = '$identifier' OR path = '$identifier' OR path = '$path';
SELECT changes();
EOF
)

    if [[ ${rows_affected:-0} -gt 0 ]]; then
        info "Removed project $identifier"
    else
        error "Error: Project not found ($identifier)"
        return 1
    fi
}

list_projects() {
    sqlite3 -column -header "$DB_FILE" <<EOF || return 1
SELECT name, path, CASE WHEN active = 1 THEN 'yes' ELSE 'no' END as active, date_added FROM projects ORDER BY date_added DESC;
EOF
}

get_project_path_by_name() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        return 1
    fi

    sqlite3 "$DB_FILE" <<EOF
SELECT path FROM projects WHERE name = '$name' LIMIT 1;
EOF
}

read_menu_key() {
    local input_fd="$1"
    local esc_seq="$2"
    local key=""
    local ch=""

    IFS= read -r -s -n 1 ch <&"$input_fd"

    if [[ -n "$esc_seq" ]]; then
        esc_seq+="$ch"
        local esc_last
        esc_last="${esc_seq:${#esc_seq}-1:1}"
        case "$esc_last" in
            [A-Za-z~])
                key="$esc_seq"
                esc_seq=""
                ;;
            *)
                MENU_KEY=""
                MENU_ESC_SEQ="$esc_seq"
                return 1
                ;;
        esac
    else
        if [[ "$ch" == $'\x1b' ]]; then
            esc_seq="$ch"
            MENU_KEY=""
            MENU_ESC_SEQ="$esc_seq"
            return 1
        fi
        key="$ch"
    fi

    MENU_KEY="$key"
    MENU_ESC_SEQ="$esc_seq"
    return 0
}

select_project() {
    local result
    result=$(sqlite3 -separator '|' "$DB_FILE" <<EOF || return 1
SELECT name, path, CASE WHEN active = 1 THEN 'yes' ELSE 'no' END as active
FROM projects
ORDER BY date_added DESC;
EOF
)

    if [[ -z "$result" ]]; then
        error "Error: No projects available"
        return 2
    fi

    local names=()
    local paths=()
    local states=()
    while IFS='|' read -r name path active; do
        names+=("$name")
        paths+=("$path")
        states+=("$active")
    done <<< "$result"

    local count="${#names[@]}"
    if [[ "$count" -eq 1 ]]; then
        echo "${names[0]}|${paths[0]}"
        return 0
    fi

    local input_fd=3
    local output_fd=3
    local tty_fd_open=0
    if exec 3<>/dev/tty 2>/dev/null; then
        tty_fd_open=1
    else
        error "Error: Interactive project selection requires a terminal"
        return 2
    fi

    local term_cols=120
    if command -v tput &>/dev/null; then
        local detected_cols
        detected_cols="$(tput cols 2>/dev/null || true)"
        if [[ "${detected_cols:-}" =~ ^[0-9]+$ ]] && [[ "$detected_cols" -gt 20 ]]; then
            term_cols="$detected_cols"
        fi
    fi

    local i=0
    local selected=0
    while [[ "$i" -lt "$count" ]]; do
        if [[ "${states[$i]}" == "yes" ]]; then
            selected="$i"
            break
        fi
        i=$((i + 1))
    done

    local rendered_lines=0
    render_menu() {
        local up=0
        while [[ "$up" -lt "$rendered_lines" ]]; do
            printf >&"$output_fd" "\033[1A"
            up=$((up + 1))
        done
        if [[ "$rendered_lines" -gt 0 ]]; then
            printf >&"$output_fd" "\033[J"
        fi

        printf >&"$output_fd" "Select active project:\n\n"
        rendered_lines=2

        local idx=0
        while [[ "$idx" -lt "$count" ]]; do
            local marker=" "
            if [[ "$idx" -eq "$selected" ]]; then
                marker=">"
            fi
            local status=""
            if [[ "${states[$idx]}" != "yes" ]]; then
                status=" [inactive]"
            fi
            local line
            line=$(printf "%s %-20s %s%s" "$marker" "${names[$idx]}" "${paths[$idx]}" "$status")
            if [[ "${#line}" -gt "$term_cols" ]]; then
                if [[ "$term_cols" -gt 4 ]]; then
                    line="${line:0:$((term_cols - 3))}..."
                else
                    line="${line:0:$term_cols}"
                fi
            fi
            printf >&"$output_fd" "%s\n" "$line"
            rendered_lines=$((rendered_lines + 1))
            idx=$((idx + 1))
        done
        printf >&"$output_fd" "\nUse up/down to select, Enter to select, q to cancel\n"
        rendered_lines=$((rendered_lines + 2))
    }

    local esc_seq=""
    render_menu
    while true; do

        local key=""
        local old_selected="$selected"
        if ! read_menu_key "$input_fd" "$esc_seq"; then
            esc_seq="$MENU_ESC_SEQ"
            continue
        fi
        key="$MENU_KEY"
        esc_seq="$MENU_ESC_SEQ"

        local key_last=""
        if [[ -n "$key" ]]; then
            key_last="${key:${#key}-1:1}"
        fi

        if [[ "$key" == "k" ]] || [[ "$key" == "K" ]] || \
           [[ "$key" == "w" ]] || [[ "$key" == "W" ]] || \
           [[ "$key" == *"[A" ]] || [[ "$key" == *"OA" ]] || \
           { [[ "$key" == $'\x1b'* ]] && [[ "$key_last" == "A" ]]; }; then
                if [[ "$selected" -gt 0 ]]; then
                    selected=$((selected - 1))
                fi
        elif [[ "$key" == "j" ]] || [[ "$key" == "J" ]] || \
             [[ "$key" == "s" ]] || [[ "$key" == "S" ]] || \
             [[ "$key" == *"[B" ]] || [[ "$key" == *"OB" ]] || \
             { [[ "$key" == $'\x1b'* ]] && [[ "$key_last" == "B" ]]; }; then
                if [[ "$selected" -lt "$((count - 1))" ]]; then
                    selected=$((selected + 1))
                fi
        else
            case "$key" in
            ""|$'\n'|$'\r')
                printf >&"$output_fd" "\n"
                if [[ "$tty_fd_open" -eq 1 ]]; then
                    exec 3<&-
                    exec 3>&-
                fi
                echo "${names[$selected]}|${paths[$selected]}"
                return 0
                ;;
            q|Q)
                printf >&"$output_fd" "\n"
                if [[ "$tty_fd_open" -eq 1 ]]; then
                    exec 3<&-
                    exec 3>&-
                fi
                return 1
                ;;
            *)
                # Ignore any unrecognized key input and keep selection unchanged.
                ;;
            esac
        fi

        if [[ "$selected" -ne "$old_selected" ]]; then
            render_menu
        fi
    done
}

set_active_project() {
    local name="$1"
    local path="$2"

    if ! sqlite3 "$DB_FILE" <<EOF
UPDATE projects
SET date_added = datetime('now')
WHERE name = '$name' AND path = '$path';
EOF
    then
        abort "Failed to persist selected project ordering for: $name ($path)"
    fi
}

# Get all projects as NUL-delimited --dir arguments
# Usage: while IFS= read -r -d '' arg; do args+=("$arg"); done < <(get_map_directories)
# Outputs NUL-delimited entries like: "--dir" NUL "name:path" NUL
get_map_directories() {
    local result
    result=$(sqlite3 -separator '|' "$DB_FILE" <<EOF || return 1
SELECT name, path FROM projects ORDER BY date_added DESC;
EOF
)

    # Always map the guest directory into the VM as "__install"
    # so install/configure scripts are available during build
    printf '%s\0' "--dir" "__install:$WORKSPACE/guest"

    if [[ -n "$result" ]]; then
        while IFS='|' read -r name path; do
            if [[ ! -d "$path" ]]; then
                abort "Directory '$path' does not exist\nTry: clod remove '$name'"
            fi
            printf '%s\0' "--dir" "${name}:${path}"
        done <<< "$result"
    fi
}

# Check if current working directory is inside active project and returns RELATIVE_PATH
# Returns 0 if inside the project, 1 otherwise
get_relative_project_directory() {
    local project_name
    project_name="$1"
    local current_dir
    current_dir="$(realpath "$PWD")"
    
    local path
    path=$(sqlite3 "$DB_FILE" <<EOF || return 1
SELECT path FROM projects WHERE name = '$project_name' AND active > 0 LIMIT 1;
EOF
)
    
    if [[ -n "$path" ]]; then
        # Check if current directory is inside this project
        path="$(realpath "$path" || true)"
        if [[ "$current_dir" == "$path" ]] || [[ "$current_dir" == "$path"/* ]]; then
            # Calculate relative path from project root
            local relative_path="${current_dir#"$path"}"
            relative_path="${relative_path#/}"  # Remove leading slash if present

            # Output the results separated by pipe
            echo "${relative_path}"
            return 0
        fi
    fi
    
    return 1
}

show_version() {
    echo "clod version $VERSION"
    exit 0
}


###############################################################################
# Setup
###############################################################################
install_tools
init_db


###############################################################################
# Parse command line
###############################################################################
NO_GRAPHICS="${NO_GRAPHICS:-}"
SHOULD_SELECT_PROJECT=true
ALLOW_SUDO=

show_help() {
    echo "Usage: clod [options] command [args...] [-- command-args...]"
    echo ""
    echo "Options:"
    echo "  --graphics           Run virtual machine with graphics (default)"
    echo "  --no-graphics        Run virtual machine without graphics"
    echo "  --rebuild-base       Force rebuild of the base image (brew update)"
    echo "  --rebuild-dst        Force rebuild of the final image (update \$HOME)"
    echo "  --allow-sudo         Allow passwordless sudo for clodpod user (rebuilds if setting changed)"
    echo "  --no-allow-sudo      Disallow sudo for clodpod user (rebuilds if setting changed)"
    echo "  -n|--no-select       Disable interactive project selection"
    echo "  -v, --verbose        Enable verbose output (repeat for more verbosity)"
    echo "  -vv                  Set verbosity level 2"
    echo "  -vvv                 Set verbosity level 3"
    echo "  -h, --help           Show this help message"
    echo "  --version            Show version information"
    echo ""
    echo "Commands:"
    echo "  cl, claude [PATH] [NAME]  Run Claude Code"
    echo "  co, codex  [PATH] [NAME]  Run OpenAI Codex"
    echo "  g,  gemini [PATH] [NAME]  Run Google Gemini"
    echo "  s,  shell  [PATH] [NAME]  Run zsh shell"
    echo "  a,  add PATH [NAME]       Add a new project"
    echo "  rm, remove <identifier>   Remove project by name or path"
    echo "  ls, list                  List all projects"
    echo "      start                 Start virtual machine"
    echo "      stop                  Stop virtual machine"
    echo ""
    echo "Arguments after -- are passed to the selected command (claude, codex, gemini, shell)"
}

# Parse optional arguments
NEW_ARGS=()
COMMAND_ARGS=()
while [[ $# -gt 0 ]]; do
    case "$1" in
        --)
            shift
            while [[ $# -gt 0 ]]; do
                COMMAND_ARGS+=("$1")
                shift
            done
            break
            ;;
        -v|--verbose)
            ((VERBOSE++)) || true
            shift
            ;;
        -vv)
            ((VERBOSE+=2)) || true
            shift
            ;;
        -vvv)
            ((VERBOSE+=3)) || true
            shift
            ;;
        --graphics)
            NO_GRAPHICS=
            shift
            ;;
        --no-graphics)
            NO_GRAPHICS=true
            shift
            ;;
        --rebuild-base)
            REBUILD_BASE=true
            shift
            ;;
        --rebuild-dst)
            REBUILD_DST=true
            shift
            ;;
        --allow-sudo)
            ALLOW_SUDO=true
            shift
            ;;
        --no-allow-sudo)
            ALLOW_SUDO=false
            shift
            ;;
        -n|--no-select)
            SHOULD_SELECT_PROJECT=false
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        --version)
            show_version
            ;;
        -*)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
        *)
            NEW_ARGS+=("$1")
            shift
            ;;
    esac
done

# bash 3.2 treats empty arrays as unbound even when initialized.
# With set -u enabled, "${NEW_ARGS[@]}" fails if the array is empty.
# The fix is to use ${array[@]+"${array[@]}"} which only expands if the array has elements.
set -- ${NEW_ARGS[@]+"${NEW_ARGS[@]}"}

# Parse fixed arguments
case "${1:-}" in
    claude|cl|c)
        COMMAND=claude
        PROJECT_DIR="${2:-}"
        PROJECT_NAME="${3:-}"
        ;;
    codex|co)
        COMMAND=codex
        PROJECT_DIR="${2:-}"
        PROJECT_NAME="${3:-}"
        ;;
    gemini|gem|g)
        COMMAND=gemini
        PROJECT_DIR="${2:-}"
        PROJECT_NAME="${3:-}"
        ;;
    shell|sh|s)
        unset COMMAND
        PROJECT_DIR="${2:-}"
        PROJECT_NAME="${3:-}"
        ;;
    start)
        COMMAND=start
        ;;
    stop)
        stop_all_vms
        exit 0
        ;;
    add|a)
        add_project "${2:-}" "${3:-}"
        exit 0
        ;;
    remove|rm)
        remove_project "${2:-}"
        exit 0
        ;;
    list|ls|l)
        list_projects
        exit 0
        ;;
    *)
        # Handle the special case that user asked for rebuild but
        # did not specify a command. We'd like to do something
        # nicer than just exit
        if [[ -z "${REBUILD_BASE:-}" ]] && [[ -z "${REBUILD_DST:-}" ]]; then
            show_help
            exit 0
        fi
        COMMAND=start
        ;;
esac

# Decide whether sudo-setting changes require rebuild
STORED_ALLOW_SUDO="$(get_setting "allow_sudo" "false")"
ALLOW_SUDO="${ALLOW_SUDO:-"$STORED_ALLOW_SUDO"}"
if [[ "$ALLOW_SUDO" != "$STORED_ALLOW_SUDO" ]]; then
    info "Sudo setting changed ($STORED_ALLOW_SUDO -> $ALLOW_SUDO); forcing base rebuild"
    REBUILD_BASE=true
    ALLOW_SUDO="$STORED_ALLOW_SUDO"
fi

# Resolve explicit command target argument
if [[ -n "${PROJECT_DIR:-}" ]]; then
    resolved_path="$(realpath "$PROJECT_DIR" 2>/dev/null || true)"
    if [[ -d "$resolved_path" ]]; then
        # PATH [NAME] form
        add_project "$PROJECT_DIR" "$PROJECT_NAME"
        SHOULD_SELECT_PROJECT=false
    elif project_path="$(get_project_path_by_name "$PROJECT_DIR")" && [[ -n "$project_path" ]]; then
        # NAME-only form
        PROJECT_NAME="$PROJECT_DIR"
        PROJECT_DIR="$project_path"
        SHOULD_SELECT_PROJECT=false
        set_active_project "$PROJECT_NAME" "$PROJECT_DIR"
    else
        abort "Error: Project not found ($PROJECT_DIR)"
    fi
fi

# Get most recent project. If none exists then add the current directory as a project.
IFS='|' read -r PROJECT_NAME PROJECT_DIR < <(sqlite3 "$DB_FILE" "SELECT name, path FROM
    projects ORDER BY date_added DESC LIMIT 1;" 2>/dev/null) || true
if [[ -z "${PROJECT_DIR:-}" ]]; then
    # Try to set the project directory to the top-level directory of the git repository
    # to minimize the number of directories that get mapped into the virtual machine.
    PROJECT_DIR="$(git rev-parse --show-toplevel 2>/dev/null)" || PROJECT_DIR="$PWD"
    PROJECT_NAME="$(basename "$PROJECT_DIR")"
    add_project "$PROJECT_DIR" "$PROJECT_NAME"
    SHOULD_SELECT_PROJECT=false
fi

if [[ "$SHOULD_SELECT_PROJECT" == "true" ]]; then
    if [[ ! -t 0 ]] || [[ ! -t 1 ]]; then
        warn "Interactive project selection disabled (no TTY); using active project"
    elif selected_project=$(select_project); then
        IFS='|' read -r PROJECT_NAME PROJECT_DIR <<< "$selected_project"
        set_active_project "$PROJECT_NAME" "$PROJECT_DIR"
    else
        selection_rc=$?
        if [[ "$selection_rc" -eq 1 ]]; then
            info "Cancelled"
            exit 1
        else
            warn "Interactive project selection unavailable; using active project"
        fi
    fi
fi

info "Active project: $PROJECT_NAME ($PROJECT_DIR)"


###############################################################################
# Create passwordless SSH key with permission to remotely login to guest
###############################################################################
SSH_DIR="$HOME/.ssh"
SSH_KEYFILE_PRIV="$SSH_DIR/id_ed25519_clodpod"
SSH_KEYFILE_PUB="$SSH_KEYFILE_PRIV.pub"
if [[ ! -f "$SSH_KEYFILE_PRIV" ]] || [[ ! -f "$SSH_KEYFILE_PUB" ]]; then
    mkdir -p "$SSH_DIR"
    ssh-keygen -t ed25519 \
        -f "$SSH_KEYFILE_PRIV" \
        -N "" \
        -q \
        -C "clodpod-${USER}@${HOSTNAME}"
    REBUILD_DST=true
fi


###############################################################################
# Download MACOS image
###############################################################################
if ! get_vm_exists "$MACOS_IMAGE" "oci" ; then
    # Defer downloading the image until after asking to stop
    # running images to avoid asking questions after a long delay
    DOWNLOAD_IMAGE=true

    # This is probably the first time install; be more verbose
    [[ "$VERBOSE" -ge 2 ]] || VERBOSE=2

    # Changing the MACOS image requires rebuild
    REBUILD_BASE=true
elif ! get_vm_exists "$BASE_VM_NAME" ; then
    REBUILD_BASE=true
elif ! get_vm_exists "$DST_VM_NAME" ; then
    REBUILD_DST=true
fi

if [[ "${REBUILD_BASE:-}" != "" ]]; then
    REBUILD_DST=true
fi

if [[ "${REBUILD_DST:-}" != "" ]]; then
    if [[ "$(get_vm_state "$DST_VM_NAME")" == "running" ]]; then
        read -p "$DST_VM_NAME is running; delete it? (y/N)" -n 1 -r response
        echo
        [[ "$response" =~ ^[Yy]$ ]] || exit 0
    fi
    delete_vm "$DST_VM_NAME"
fi

if [[ "${DOWNLOAD_IMAGE:-}" != "" ]]; then
    debug "Downloading image..."
    tart pull "$MACOS_IMAGE" # >/dev/null
fi


###############################################################################
# Configure virtual machine settings
###############################################################################
if [[ "${REBUILD_DST:-}" != "" ]]; then
    debug "Configuring credentials..."

    # Get git config from host
    GIT_USER_NAME=$(git config --global --get user.name 2>/dev/null || echo "")
    GIT_USER_EMAIL=$(git config --global --get user.email 2>/dev/null || echo "")
    git config set -f "$WORKSPACE/guest/home/.gitconfig" user.name "$GIT_USER_NAME"
    git config set -f "$WORKSPACE/guest/home/.gitconfig" user.email "$GIT_USER_EMAIL"

    # Add SSH public key to host's authorized_keys
    GUEST_AUTHORIZED_KEYS="$WORKSPACE/guest/home/.ssh/authorized_keys"
    mkdir -p "$(dirname "$GUEST_AUTHORIZED_KEYS")"
    cp "$SSH_KEYFILE_PUB" "$GUEST_AUTHORIZED_KEYS"
    chmod 600 "$GUEST_AUTHORIZED_KEYS"
fi

# https://github.com/webcoyote/clodpod/issues/5
# Starting & stopping many VMs causes a DHCP IP address shortage.
#
# Tart recommends: You might want to reduce the default DHCP lease time
# from 86,400 to 600 seconds to avoid DHCP shortage when running lots of VMs daily:
# https://tart.run/faq/#changing-the-default-dhcp-lease-time
#
# Update Internet Sharing's DHCP lease time via SystemConfiguration prefs.
DHCP_PREFS="/Library/Preferences/SystemConfiguration/com.apple.InternetSharing.default.plist"
CURRENT_LEASE=$(/usr/libexec/PlistBuddy -c "Print :bootpd:DHCPLeaseTimeSecs" "$DHCP_PREFS" 2>/dev/null || true)
if [[ "$CURRENT_LEASE" != "600" ]]; then
    sudo -p "Password required to set DHCP lease time for clodpod (600s): " true
    sudo /usr/bin/defaults write "$DHCP_PREFS" bootpd -dict DHCPLeaseTimeSecs -int 600
    sudo /bin/launchctl stop com.apple.InternetSharing || true
    sudo /bin/launchctl start com.apple.InternetSharing || true
fi


###############################################################################
# Create Base VM
###############################################################################
# It's possible this script will fail or be cancelled halfway
# through so build to a temporary image and rename when complete
TMP_VM_NAME="clodpod-tmp-$(openssl rand -hex 8)"
trap cleanup_tmp_vm EXIT

if [[ "${REBUILD_BASE:-}" != "" ]]; then
    debug "Building $BASE_VM_NAME..."
    delete_vm "$BASE_VM_NAME"

    trace "Cloning image to $TMP_VM_NAME..."
    clone_vm "$MACOS_IMAGE" "$TMP_VM_NAME"
    run_vm "$TMP_VM_NAME"

    trace "Running install.sh..."
    INSTALL_ENV=( "/usr/bin/env" "VERBOSE=$VERBOSE" "ALLOW_SUDO=$ALLOW_SUDO" )
    if [[ -n "${CLODPOD_PASSWORD:-}" ]]; then
        INSTALL_ENV+=( "CLODPOD_PASSWORD=$CLODPOD_PASSWORD" )
    fi

    tart exec -it "$TMP_VM_NAME" \
        "${INSTALL_ENV[@]}" bash \
        "/Volumes/My Shared Files/__install/install.sh"

    trace "Renaming $TMP_VM_NAME to $BASE_VM_NAME"
    tart rename "$TMP_VM_NAME" "$BASE_VM_NAME"
    set_setting "allow_sudo" "$ALLOW_SUDO"

    debug "Building $BASE_VM_NAME successful"
fi


###############################################################################
# Create Dst VM
###############################################################################
if [[ "${REBUILD_DST:-}" != "" ]]; then
    debug "Building $DST_VM_NAME..."

    # If the base image is already running then do some jiggery-pokery
    # to rename it so we can avoid stopping the VM and starting another.
    #
    # Note that this leaves the application window title unchanged, but
    # it's faster than stopping and starting the VM.
    if [[ "$(get_vm_state "$BASE_VM_NAME")" == "running" ]]; then
        tart rename "$BASE_VM_NAME" "$TMP_VM_NAME"
        clone_vm "$TMP_VM_NAME" "$BASE_VM_NAME"
    else
        clone_vm "$BASE_VM_NAME" "$TMP_VM_NAME"
        run_vm "$TMP_VM_NAME"
    fi

    trace "Running configure.sh..."
    tart exec -it "$TMP_VM_NAME" \
        "/usr/bin/env" "VERBOSE=$VERBOSE" bash \
        "/Volumes/My Shared Files/__install/configure.sh"

    trace "Renaming $TMP_VM_NAME to $DST_VM_NAME"
    tart rename "$TMP_VM_NAME" "$DST_VM_NAME"

    debug "Building $DST_VM_NAME successful"
fi


###############################################################################
# start the application
###############################################################################
# kitty doesn't set this properly :(
TERM_PROGRAM="${TERM_PROGRAM:-e.g. ghostty, kitty, iTerm, WezTerm}"
heredoc LOCAL_NETWORK_ERROR << EOF
\n
ERROR: unable to connect to $DST_VM_NAME.

Your terminal app ($TERM_PROGRAM)
has not been granted "Local Network" access rights,
which are required to SSH to the Virtual Machine.

- Open "System Settings.app"
- Navigate to "Privacy & Security"
- Select "Local Network"
- Grant access to your terminal application
\n
EOF

if [[ "$(get_vm_state "$DST_VM_NAME")" != "running" ]]; then
    run_vm "$DST_VM_NAME"
elif ! check_projects_active ; then
    warn "New project directory added; virtual machine restart required"
    read -p "$DST_VM_NAME is running; restart it? (y/N)" -n 1 -r response
    echo
    [[ "$response" =~ ^[Yy]$ ]] || exit 0
    stop_vm "$DST_VM_NAME"
    run_vm "$DST_VM_NAME"
fi

if [[ "${COMMAND:-}" == "start" ]]; then
    info "clodpod VM running"
    exit 0
fi

debug "Checking $DST_VM_NAME IP connectivity"
IPADDR="$(tart ip --wait 20 "$DST_VM_NAME")"
if ! nc -z "$IPADDR" 22 ; then
    # shellcheck disable=SC2154 # LOCAL_NETWORK_ERROR is referenced but not assigned (yes it is)
    error "$LOCAL_NETWORK_ERROR"
    read -n 1 -s -r -p "Press any key to open System Settings"
    open "/System/Library/PreferencePanes/Security.prefPane"
fi

debug "Connect to $DST_VM_NAME (ssh clodpod@$IPADDR)"

COMMAND_ARGS_B64=""
if [[ ${#COMMAND_ARGS[@]} -gt 0 ]]; then
    COMMAND_ARGS_B64="$(printf '%s\0' "${COMMAND_ARGS[@]}" | base64 | tr -d '\n')"
fi

# Check if current directory is inside existing project
INITIAL_DIR=""
if initial_dir=$(get_relative_project_directory "$PROJECT_NAME"); then
    INITIAL_DIR="$initial_dir"
    debug "initial directory: ${INITIAL_DIR:-}"
fi

exec ssh \
    -q \
    -t \
    -o StrictHostKeyChecking=no \
    -o UserKnownHostsFile=/dev/null \
    -i "$SSH_KEYFILE_PRIV" \
    "clodpod@$IPADDR" \
    /usr/bin/env \
        "PROJECT=$PROJECT_NAME" \
        "INITIAL_DIR=$INITIAL_DIR" \
        "COMMAND=${COMMAND:-}" \
        "COMMAND_ARGS_B64=$COMMAND_ARGS_B64" \
        zsh --login || true
